using System.Linq;
using TraitSharp.SourceGenerator.Models;
using TraitSharp.SourceGenerator.Utilities;

namespace TraitSharp.SourceGenerator.Generators
{
    /// <summary>
    /// Generates a metadata class annotated with [TraitDefaultBody] attributes
    /// for each trait method that has a default body. This allows the consuming
    /// assembly's source generator to discover default method body text across
    /// compilation boundaries, where DeclaringSyntaxReferences would be empty.
    /// </summary>
    internal static class DefaultBodyMetadataGenerator
    {
        /// <summary>
        /// Generates a metadata class for the given trait if it has any methods with default bodies.
        /// Returns null if there are no default methods to record.
        /// </summary>
        public static string? Generate(TraitModel trait)
        {
            // Collect all methods with default bodies (own + inherited)
            var defaultMethods = trait.Methods
                .Where(m => m.HasDefaultBody && m.DefaultBodySyntax != null)
                .ToList();

            if (defaultMethods.Count == 0)
                return null;

            var builder = new CodeBuilder();
            var metadataClassName = $"{trait.ShortName}TraitDefaults";

            builder.AppendLine("// <auto-generated/>");
            builder.AppendLine("#nullable enable");
            builder.AppendLine();
            builder.AppendLine($"namespace {trait.EffectiveNamespace}");
            builder.OpenBrace();

            builder.AppendLine("/// <summary>");
            builder.AppendLine($"/// Stores default method body metadata for {trait.Name}.");
            builder.AppendLine("/// Used by the source generator to emit default implementations");
            builder.AppendLine("/// in consuming assemblies where syntax references are unavailable.");
            builder.AppendLine("/// </summary>");

            foreach (var method in defaultMethods)
            {
                // Escape the body syntax for use as a C# string literal
                var escaped = EscapeForStringLiteral(method.DefaultBodySyntax!);
                builder.AppendLine($"[TraitSharp.TraitDefaultBody(\"{method.Name}\", \"{escaped}\")]");
            }

            builder.AppendLine($"internal static class {metadataClassName} {{ }}");

            builder.CloseBrace();

            return builder.ToString();
        }

        /// <summary>
        /// Gets the metadata class name for a trait.
        /// E.g., IExternalShape -> ExternalShapeTraitDefaults
        /// </summary>
        public static string GetMetadataClassName(TraitModel trait)
        {
            return $"{trait.ShortName}TraitDefaults";
        }

        /// <summary>
        /// Gets the fully qualified metadata class name.
        /// </summary>
        public static string GetFullMetadataClassName(TraitModel trait)
        {
            return $"{trait.EffectiveNamespace}.{GetMetadataClassName(trait)}";
        }

        /// <summary>
        /// Escapes a string for use inside a C# string literal (double-quoted).
        /// </summary>
        private static string EscapeForStringLiteral(string text)
        {
            return text
                .Replace("\\", "\\\\")
                .Replace("\"", "\\\"")
                .Replace("\r\n", "\\n")
                .Replace("\n", "\\n")
                .Replace("\r", "\\n")
                .Replace("\t", "\\t");
        }
    }
}
