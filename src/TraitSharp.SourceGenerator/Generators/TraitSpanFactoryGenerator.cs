using TraitSharp.SourceGenerator.Models;
using TraitSharp.SourceGenerator.Utilities;

namespace TraitSharp.SourceGenerator.Generators
{
    internal static class TraitSpanFactoryGenerator
    {
        /// <summary>
        /// Generates span factory extension methods for a trait.
        /// Produces AsXxxSpan, AsXxxTraitSpan, AsXxxSpan2D, AsXxxTraitSpan2D methods.
        /// </summary>
        public static string Generate(TraitModel trait)
        {
            var builder = new CodeBuilder();
            var contractName = ConstraintInterfaceGenerator.GetContractName(trait);
            var shortName = trait.ShortName;
            var layoutType = $"{trait.EffectiveNamespace}.{trait.LayoutStructName}";

            builder.AppendLine("// <auto-generated/>");
            builder.AppendLine("#nullable enable");
            builder.AppendLine("using System;");
            builder.AppendLine("using System.Runtime.CompilerServices;");
            builder.AppendLine("using System.Runtime.InteropServices;");
            builder.AppendLine("using TraitSharp.Runtime;");
            builder.AppendLine();
            builder.AppendLine($"namespace {trait.EffectiveNamespace}");
            builder.OpenBrace();

            builder.AppendLine("/// <summary>");
            builder.AppendLine($"/// Span factory extension methods for {trait.Name} trait.");
            builder.AppendLine("/// </summary>");
            builder.AppendLine($"public static class {trait.Name}SpanExtensions");
            builder.OpenBrace();

            // 1. AsXxxSpan - ReadOnly from ReadOnlySpan<T>
            builder.AppendLine("/// <summary>");
            builder.AppendLine($"/// Creates a read-only trait span viewing {trait.Name} fields across all elements.");
            builder.AppendLine("/// </summary>");
            builder.AppendLine("[MethodImpl(MethodImplOptions.AggressiveInlining)]");
            builder.AppendLine($"public static ReadOnlyTraitSpan<{layoutType}> As{shortName}Span<T>(");
            builder.AppendLine($"    this ReadOnlySpan<T> source)");
            builder.AppendLine($"    where T : unmanaged, {contractName}<T>");
            builder.OpenBrace();
            builder.AppendLine($"int offset = T.TraitOffset;");
            builder.AppendLine($"return new ReadOnlyTraitSpan<{layoutType}>(");
            builder.AppendLine("    ref Unsafe.AddByteOffset(");
            builder.AppendLine("        ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(source)),");
            builder.AppendLine("        (nint)offset),");
            builder.AppendLine("    Unsafe.SizeOf<T>(),");
            builder.AppendLine("    source.Length);");
            builder.CloseBrace();
            builder.AppendLine();

            // 1b. AsXxxSpan - ReadOnly from Span<T> (so Span<T> users get ReadOnly without ambiguity)
            builder.AppendLine("/// <summary>");
            builder.AppendLine($"/// Creates a read-only trait span viewing {trait.Name} fields across all elements.");
            builder.AppendLine("/// </summary>");
            builder.AppendLine("[MethodImpl(MethodImplOptions.AggressiveInlining)]");
            builder.AppendLine($"public static ReadOnlyTraitSpan<{layoutType}> As{shortName}Span<T>(");
            builder.AppendLine($"    this Span<T> source)");
            builder.AppendLine($"    where T : unmanaged, {contractName}<T>");
            builder.OpenBrace();
            builder.AppendLine($"return As{shortName}Span<T>((ReadOnlySpan<T>)source);");
            builder.CloseBrace();
            builder.AppendLine();

            // 2. AsXxxTraitSpan - Mutable from Span<T>
            builder.AppendLine("/// <summary>");
            builder.AppendLine($"/// Creates a mutable trait span viewing {trait.Name} fields across all elements.");
            builder.AppendLine("/// </summary>");
            builder.AppendLine("[MethodImpl(MethodImplOptions.AggressiveInlining)]");
            builder.AppendLine($"public static TraitSpan<{layoutType}> As{shortName}TraitSpan<T>(");
            builder.AppendLine($"    this Span<T> source)");
            builder.AppendLine($"    where T : unmanaged, {contractName}<T>");
            builder.OpenBrace();
            builder.AppendLine($"int offset = T.TraitOffset;");
            builder.AppendLine($"return new TraitSpan<{layoutType}>(");
            builder.AppendLine("    ref Unsafe.AddByteOffset(");
            builder.AppendLine("        ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(source)),");
            builder.AppendLine("        (nint)offset),");
            builder.AppendLine("    Unsafe.SizeOf<T>(),");
            builder.AppendLine("    source.Length);");
            builder.CloseBrace();
            builder.AppendLine();

            // 3. AsXxxSpan2D - ReadOnly 2D from ReadOnlySpan<T>
            builder.AppendLine("/// <summary>");
            builder.AppendLine($"/// Creates a 2D read-only trait span with the given dimensions.");
            builder.AppendLine("/// source.Length must equal width * height.");
            builder.AppendLine("/// </summary>");
            builder.AppendLine("[MethodImpl(MethodImplOptions.AggressiveInlining)]");
            builder.AppendLine($"public static ReadOnlyTraitSpan2D<{layoutType}> As{shortName}Span2D<T>(");
            builder.AppendLine($"    this ReadOnlySpan<T> source, int width, int height)");
            builder.AppendLine($"    where T : unmanaged, {contractName}<T>");
            builder.OpenBrace();
            builder.AppendLine("if (source.Length != width * height)");
            builder.AppendLine("    ThrowHelper.ThrowArgumentException_InvalidDimensions();");
            builder.AppendLine($"int offset = T.TraitOffset;");
            builder.AppendLine($"return new ReadOnlyTraitSpan2D<{layoutType}>(");
            builder.AppendLine("    ref Unsafe.AddByteOffset(");
            builder.AppendLine("        ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(source)),");
            builder.AppendLine("        (nint)offset),");
            builder.AppendLine("    Unsafe.SizeOf<T>(),");
            builder.AppendLine("    width,");
            builder.AppendLine("    height);");
            builder.CloseBrace();
            builder.AppendLine();

            // 3b. AsXxxSpan2D - ReadOnly 2D from Span<T>
            builder.AppendLine("/// <summary>");
            builder.AppendLine($"/// Creates a 2D read-only trait span with the given dimensions.");
            builder.AppendLine("/// source.Length must equal width * height.");
            builder.AppendLine("/// </summary>");
            builder.AppendLine("[MethodImpl(MethodImplOptions.AggressiveInlining)]");
            builder.AppendLine($"public static ReadOnlyTraitSpan2D<{layoutType}> As{shortName}Span2D<T>(");
            builder.AppendLine($"    this Span<T> source, int width, int height)");
            builder.AppendLine($"    where T : unmanaged, {contractName}<T>");
            builder.OpenBrace();
            builder.AppendLine($"return As{shortName}Span2D<T>((ReadOnlySpan<T>)source, width, height);");
            builder.CloseBrace();
            builder.AppendLine();

            // 4. AsXxxTraitSpan2D - Mutable 2D from Span<T>
            builder.AppendLine("/// <summary>");
            builder.AppendLine($"/// Creates a 2D mutable trait span with the given dimensions.");
            builder.AppendLine("/// source.Length must equal width * height.");
            builder.AppendLine("/// </summary>");
            builder.AppendLine("[MethodImpl(MethodImplOptions.AggressiveInlining)]");
            builder.AppendLine($"public static TraitSpan2D<{layoutType}> As{shortName}TraitSpan2D<T>(");
            builder.AppendLine($"    this Span<T> source, int width, int height)");
            builder.AppendLine($"    where T : unmanaged, {contractName}<T>");
            builder.OpenBrace();
            builder.AppendLine("if (source.Length != width * height)");
            builder.AppendLine("    ThrowHelper.ThrowArgumentException_InvalidDimensions();");
            builder.AppendLine($"int offset = T.TraitOffset;");
            builder.AppendLine($"return new TraitSpan2D<{layoutType}>(");
            builder.AppendLine("    ref Unsafe.AddByteOffset(");
            builder.AppendLine("        ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(source)),");
            builder.AppendLine("        (nint)offset),");
            builder.AppendLine("    Unsafe.SizeOf<T>(),");
            builder.AppendLine("    width,");
            builder.AppendLine("    height);");
            builder.CloseBrace();
            builder.AppendLine();

            // --- Native Span fast-path factory methods ---
            // These return Span<TLayout> / ReadOnlySpan<TLayout> directly via MemoryMarshal.Cast
            // when the backing struct is 1:1 compatible (same size, zero offset).
            // The JIT constant-folds the guard: T.TraitOffset and Unsafe.SizeOf<T>() are both
            // JIT-time constants for any concrete T, so the branch is dead-code-eliminated.
            // This enables full SIMD auto-vectorization that strided TraitSpan cannot achieve.

            // 5. AsXxxNativeSpan - ReadOnly native span from ReadOnlySpan<T>
            builder.AppendLine("/// <summary>");
            builder.AppendLine($"/// Returns a native ReadOnlySpan&lt;{trait.LayoutStructName}&gt; viewing {trait.Name} fields,");
            builder.AppendLine("/// enabling SIMD auto-vectorization. Requires 1:1 layout compatibility:");
            builder.AppendLine("/// the backing struct must have the same size as the layout and zero trait offset.");
            builder.AppendLine("/// </summary>");
            builder.AppendLine("/// <exception cref=\"InvalidOperationException\">");
            builder.AppendLine("/// Thrown when the backing type is not 1:1 layout compatible.");
            builder.AppendLine("/// </exception>");
            builder.AppendLine("[MethodImpl(MethodImplOptions.AggressiveInlining)]");
            builder.AppendLine($"public static ReadOnlySpan<{layoutType}> As{shortName}NativeSpan<T>(");
            builder.AppendLine($"    this ReadOnlySpan<T> source)");
            builder.AppendLine($"    where T : unmanaged, {contractName}<T>");
            builder.OpenBrace();
            builder.AppendLine($"if (T.TraitOffset != 0 || Unsafe.SizeOf<T>() != Unsafe.SizeOf<{layoutType}>())");
            builder.AppendLine($"    ThrowHelper.ThrowInvalidOperationException_NotLayoutCompatible();");
            builder.AppendLine($"return MemoryMarshal.Cast<T, {layoutType}>(source);");
            builder.CloseBrace();
            builder.AppendLine();

            // 5b. AsXxxNativeSpan - ReadOnly native span from Span<T>
            builder.AppendLine("/// <summary>");
            builder.AppendLine($"/// Returns a native ReadOnlySpan&lt;{trait.LayoutStructName}&gt; viewing {trait.Name} fields,");
            builder.AppendLine("/// enabling SIMD auto-vectorization. Requires 1:1 layout compatibility.");
            builder.AppendLine("/// </summary>");
            builder.AppendLine("[MethodImpl(MethodImplOptions.AggressiveInlining)]");
            builder.AppendLine($"public static ReadOnlySpan<{layoutType}> As{shortName}NativeSpan<T>(");
            builder.AppendLine($"    this Span<T> source)");
            builder.AppendLine($"    where T : unmanaged, {contractName}<T>");
            builder.OpenBrace();
            builder.AppendLine($"return As{shortName}NativeSpan<T>((ReadOnlySpan<T>)source);");
            builder.CloseBrace();
            builder.AppendLine();

            // 6. AsXxxNativeTraitSpan - Mutable native span from Span<T>
            builder.AppendLine("/// <summary>");
            builder.AppendLine($"/// Returns a native Span&lt;{trait.LayoutStructName}&gt; viewing {trait.Name} fields,");
            builder.AppendLine("/// enabling SIMD auto-vectorization. Requires 1:1 layout compatibility:");
            builder.AppendLine("/// the backing struct must have the same size as the layout and zero trait offset.");
            builder.AppendLine("/// </summary>");
            builder.AppendLine("/// <exception cref=\"InvalidOperationException\">");
            builder.AppendLine("/// Thrown when the backing type is not 1:1 layout compatible.");
            builder.AppendLine("/// </exception>");
            builder.AppendLine("[MethodImpl(MethodImplOptions.AggressiveInlining)]");
            builder.AppendLine($"public static Span<{layoutType}> As{shortName}NativeTraitSpan<T>(");
            builder.AppendLine($"    this Span<T> source)");
            builder.AppendLine($"    where T : unmanaged, {contractName}<T>");
            builder.OpenBrace();
            builder.AppendLine($"if (T.TraitOffset != 0 || Unsafe.SizeOf<T>() != Unsafe.SizeOf<{layoutType}>())");
            builder.AppendLine($"    ThrowHelper.ThrowInvalidOperationException_NotLayoutCompatible();");
            builder.AppendLine($"return MemoryMarshal.Cast<T, {layoutType}>(source);");
            builder.CloseBrace();
            builder.AppendLine();

            // 7. TryAsXxxNativeSpan - Safe try-pattern for ReadOnly
            builder.AppendLine("/// <summary>");
            builder.AppendLine($"/// Attempts to return a native ReadOnlySpan&lt;{trait.LayoutStructName}&gt; viewing {trait.Name} fields.");
            builder.AppendLine("/// Returns true and sets result if the backing type is 1:1 layout compatible;");
            builder.AppendLine("/// returns false otherwise. Use this for safe conditional optimization.");
            builder.AppendLine("/// </summary>");
            builder.AppendLine("[MethodImpl(MethodImplOptions.AggressiveInlining)]");
            builder.AppendLine($"public static bool TryAs{shortName}NativeSpan<T>(");
            builder.AppendLine($"    this ReadOnlySpan<T> source,");
            builder.AppendLine($"    out ReadOnlySpan<{layoutType}> result)");
            builder.AppendLine($"    where T : unmanaged, {contractName}<T>");
            builder.OpenBrace();
            builder.AppendLine($"if (T.TraitOffset == 0 && Unsafe.SizeOf<T>() == Unsafe.SizeOf<{layoutType}>())");
            builder.OpenBrace();
            builder.AppendLine($"result = MemoryMarshal.Cast<T, {layoutType}>(source);");
            builder.AppendLine("return true;");
            builder.CloseBrace();
            builder.AppendLine($"result = default;");
            builder.AppendLine("return false;");
            builder.CloseBrace();
            builder.AppendLine();

            // 8. TryAsXxxNativeTraitSpan - Safe try-pattern for Mutable
            builder.AppendLine("/// <summary>");
            builder.AppendLine($"/// Attempts to return a native Span&lt;{trait.LayoutStructName}&gt; viewing {trait.Name} fields.");
            builder.AppendLine("/// Returns true and sets result if the backing type is 1:1 layout compatible;");
            builder.AppendLine("/// returns false otherwise. Use this for safe conditional optimization.");
            builder.AppendLine("/// </summary>");
            builder.AppendLine("[MethodImpl(MethodImplOptions.AggressiveInlining)]");
            builder.AppendLine($"public static bool TryAs{shortName}NativeTraitSpan<T>(");
            builder.AppendLine($"    this Span<T> source,");
            builder.AppendLine($"    out Span<{layoutType}> result)");
            builder.AppendLine($"    where T : unmanaged, {contractName}<T>");
            builder.OpenBrace();
            builder.AppendLine($"if (T.TraitOffset == 0 && Unsafe.SizeOf<T>() == Unsafe.SizeOf<{layoutType}>())");
            builder.OpenBrace();
            builder.AppendLine($"result = MemoryMarshal.Cast<T, {layoutType}>(source);");
            builder.AppendLine("return true;");
            builder.CloseBrace();
            builder.AppendLine($"result = default;");
            builder.AppendLine("return false;");
            builder.CloseBrace();

            builder.CloseBrace();
            builder.CloseBrace();

            return builder.ToString();
        }
    }
}
