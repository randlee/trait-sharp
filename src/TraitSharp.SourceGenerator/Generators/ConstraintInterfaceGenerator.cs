using TraitSharp.SourceGenerator.Models;
using TraitSharp.SourceGenerator.Utilities;

namespace TraitSharp.SourceGenerator.Generators
{
    internal static class ConstraintInterfaceGenerator
    {
        /// <summary>
        /// Generates the single marker interface ITrait&lt;TTrait, TSelf&gt; in the given namespace.
        /// This is generated once per namespace, not once per trait.
        /// </summary>
        public static string GenerateMarker(string ns)
        {
            var builder = new CodeBuilder();

            builder.AppendLine("// <auto-generated/>");
            builder.AppendLine("#nullable enable");
            builder.AppendLine();
            builder.AppendLine($"namespace {ns}");
            builder.OpenBrace();

            builder.AppendLine("/// <summary>");
            builder.AppendLine("/// Marker interface for trait implementations.");
            builder.AppendLine("/// Each trait defines a specific contract interface that extends this marker.");
            builder.AppendLine("/// </summary>");
            builder.AppendLine("public interface ITrait<TTrait, TSelf> where TSelf : unmanaged { }");

            builder.CloseBrace();

            return builder.ToString();
        }

        /// <summary>
        /// Generates a per-trait contract interface, e.g. ICoordinateTrait&lt;TSelf&gt;.
        /// This interface extends ITrait&lt;ICoordinate, TSelf&gt; and contains the
        /// static abstract members specific to this trait.
        /// </summary>
        public static string GenerateContract(TraitModel trait)
        {
            var builder = new CodeBuilder();
            var contractName = GetContractName(trait);

            builder.AppendLine("// <auto-generated/>");
            builder.AppendLine("#nullable enable");
            builder.AppendLine();
            builder.AppendLine($"namespace {trait.EffectiveNamespace}");
            builder.OpenBrace();

            builder.AppendLine("/// <summary>");
            builder.AppendLine($"/// Contract interface for {trait.Name} trait implementations.");
            builder.AppendLine("/// </summary>");

            // Build base interface list
            var baseInterfaces = $"ITrait<{trait.Name}, TSelf>";
            if (trait.HasBaseTraits)
            {
                foreach (var baseTrait in trait.BaseTraits)
                {
                    var baseContractName = GetContractName(baseTrait);
                    var baseNs = baseTrait.EffectiveNamespace;
                    var ns = trait.EffectiveNamespace;
                    // If same namespace, use short name; otherwise fully qualify
                    if (baseNs == ns)
                        baseInterfaces += $", {baseContractName}<TSelf>";
                    else
                        baseInterfaces += $", {baseNs}.{baseContractName}<TSelf>";
                }
            }
            builder.AppendLine($"public interface {contractName}<TSelf> : {baseInterfaces} where TSelf : unmanaged");
            builder.OpenBrace();

            // Property accessors — only declare members NEW on this trait (not inherited).
            // Inherited members come from base contract interfaces via C# interface inheritance.
            // For derived traits, OwnProperties may be empty (trait adds no new properties) — that's correct.
            var ownProps = trait.HasBaseTraits ? trait.OwnProperties : trait.Properties;
            foreach (var prop in ownProps)
            {
                builder.AppendLine($"static abstract {prop.TypeName} Get{prop.Name}_Impl(in TSelf self);");
            }

            // Method declarations — own only (inherited come from base contracts)
            var ownMethods = trait.HasBaseTraits ? trait.OwnMethods : trait.Methods;
            foreach (var method in ownMethods)
            {
                var returnType = method.ReturnsSelf ? "TSelf" : method.ReturnType;
                var paramList = "in TSelf self";
                foreach (var param in method.Parameters)
                {
                    var typeName = param.IsSelf ? "TSelf" : param.TypeName;
                    var modifier = string.IsNullOrEmpty(param.Modifier) ? "" : param.Modifier + " ";
                    paramList += $", {modifier}{typeName} {param.Name}";
                }
                builder.AppendLine($"static abstract {returnType} {method.ImplMethodName}({paramList});");
            }

            // AsLayout + TraitOffset — each trait level declares its own.
            // For derived traits, use 'new' to shadow the base contract's declarations
            // since each level has a different layout struct return type.
            var newPrefix = trait.HasBaseTraits ? "new " : "";
            builder.AppendLine($"{newPrefix}static abstract ref readonly {trait.LayoutStructName} AsLayout(in TSelf self);");
            builder.AppendLine($"{newPrefix}static abstract int TraitOffset {{ get; }}");

            builder.CloseBrace();
            builder.CloseBrace();

            return builder.ToString();
        }

        /// <summary>
        /// Gets the per-trait contract interface name: ICoordinate -> ICoordinateTrait
        /// </summary>
        public static string GetContractName(TraitModel trait)
        {
            return $"{trait.Name}Trait";
        }

        /// <summary>
        /// Gets the fully qualified per-trait contract interface name.
        /// </summary>
        public static string GetFullContractName(TraitModel trait)
        {
            return $"{trait.EffectiveNamespace}.{GetContractName(trait)}";
        }
    }
}
