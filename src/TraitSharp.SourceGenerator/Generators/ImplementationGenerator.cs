using System.Collections.Generic;
using System.Linq;
using TraitSharp.SourceGenerator.Models;
using TraitSharp.SourceGenerator.Utilities;

namespace TraitSharp.SourceGenerator.Generators
{
    internal static class ImplementationGenerator
    {
        public static string Generate(ImplementationModel impl)
        {
            var trait = impl.Trait!;
            var builder = new CodeBuilder();
            var contractName = ConstraintInterfaceGenerator.GetContractName(trait);
            var fullContractName = $"{trait.EffectiveNamespace}.{contractName}";

            builder.AppendLine("// <auto-generated/>");
            builder.AppendLine("#nullable enable");
            builder.AppendLine("using System.Runtime.CompilerServices;");
            builder.AppendLine();
            builder.AppendLine($"namespace {impl.Namespace}");
            builder.OpenBrace();

            // Implement the per-trait contract interface instead of ITrait<TraitName, TSelf>
            builder.AppendLine($"partial {impl.TypeKind} {impl.TypeName} : {fullContractName}<{impl.TypeName}>");
            builder.OpenBrace();

            // Property accessors - these have unique names per trait (GetX_Impl, GetR_Impl, etc.)
            // so they don't need explicit interface implementation
            foreach (var prop in trait.Properties)
            {
                builder.AppendLine("[MethodImpl(MethodImplOptions.AggressiveInlining)]");
                builder.AppendLine($"public static {prop.TypeName} Get{prop.Name}_Impl(in {impl.TypeName} self)");
                builder.OpenBrace();

                string fieldName;
                if (impl.FieldMapping.TryGetValue(prop.Name, out var mappedName))
                {
                    fieldName = mappedName;
                }
                else
                {
                    fieldName = prop.Name;
                }

                builder.AppendLine($"return self.{fieldName};");
                builder.CloseBrace();
                builder.AppendLine();
            }

            // Default method implementations — emit for trait methods that have a default body
            // and where the implementing type does NOT provide its own override (static {Name}_Impl method)
            foreach (var method in trait.Methods)
            {
                if (!method.HasDefaultBody) continue;

                // Check if the implementing type already provides an override
                if (HasUserOverride(impl, method)) continue;

                // Rewrite the default body to use static dispatch
                var rewrittenBody = DefaultBodyRewriter.Rewrite(
                    method.DefaultBodySyntax!, trait, impl.TypeName);

                if (rewrittenBody == null) continue; // Rewrite failed — skip (TE0013 reported elsewhere if needed)

                var returnType = method.ReturnsSelf ? impl.TypeName : method.ReturnType;
                var paramList = $"in {impl.TypeName} self";
                foreach (var param in method.Parameters)
                {
                    var typeName = param.IsSelf ? impl.TypeName : param.TypeName;
                    var modifier = string.IsNullOrEmpty(param.Modifier) ? "" : param.Modifier + " ";
                    paramList += $", {modifier}{typeName} {param.Name}";
                }

                builder.AppendLine($"// Default implementation from {trait.Name}.{method.Name}");
                builder.AppendLine("[MethodImpl(MethodImplOptions.AggressiveInlining)]");
                builder.AppendLine($"public static {returnType} {method.ImplMethodName}({paramList})");
                // Emit the rewritten body directly
                builder.AppendLine(rewrittenBody);
                builder.AppendLine();
            }

            // TraitOffset + AsLayout for the leaf trait
            EmitTraitOffsetAndAsLayout(builder, trait, impl);

            // TraitOffset + AsLayout for ALL ancestor traits in the hierarchy.
            // When IQuadrupler : IDoubler : IValueProvider, the struct must satisfy
            // all three contract interfaces' TraitOffset/AsLayout requirements.
            var ancestors = CollectAncestorTraits(trait);
            foreach (var ancestor in ancestors)
            {
                EmitTraitOffsetAndAsLayout(builder, ancestor, impl);
            }

            builder.CloseBrace();
            builder.CloseBrace();

            return builder.ToString();
        }

        /// <summary>
        /// Emits explicit interface implementation of TraitOffset and AsLayout for a single trait level.
        /// </summary>
        private static void EmitTraitOffsetAndAsLayout(CodeBuilder builder, TraitModel traitLevel, ImplementationModel impl)
        {
            var contractName = ConstraintInterfaceGenerator.GetContractName(traitLevel);
            var fullContractName = $"{traitLevel.EffectiveNamespace}.{contractName}";

            // TraitOffset property - use explicit interface implementation to avoid
            // name collision when a struct implements multiple traits
            builder.AppendLine($"static int {fullContractName}<{impl.TypeName}>.TraitOffset => {impl.BaseOffset};");
            builder.AppendLine();

            // Layout cast — use explicit interface implementation to avoid name collision
            // when a struct implements multiple traits (each returns a different layout type)
            builder.AppendLine("[MethodImpl(MethodImplOptions.AggressiveInlining)]");
            builder.AppendLine($"static ref readonly {traitLevel.EffectiveNamespace}.{traitLevel.LayoutStructName} {fullContractName}<{impl.TypeName}>.AsLayout(in {impl.TypeName} self)");
            builder.OpenBrace();

            if (impl.BaseOffset == 0)
            {
                // Trait fields start at beginning of struct — simple cast
                var props = traitLevel.Properties.Count > 0 ? traitLevel.Properties : traitLevel.OwnProperties;
                var fieldsList = string.Join("; ", props.Select(p => $"{p.TypeName} {p.Name}"));
                builder.AppendLine($"// SAFETY: Generator verified {impl.TypeName} starts with {{{fieldsList}}}");
                builder.AppendLine($"return ref global::System.Runtime.CompilerServices.Unsafe.As<{impl.TypeName}, {traitLevel.EffectiveNamespace}.{traitLevel.LayoutStructName}>(");
                builder.AppendLine($"    ref global::System.Runtime.CompilerServices.Unsafe.AsRef(in self));");
            }
            else
            {
                // Trait fields at non-zero offset — add byte offset before cast
                builder.AppendLine($"// SAFETY: Generator verified {traitLevel.Name} fields at byte offset {impl.BaseOffset}");
                builder.AppendLine($"return ref global::System.Runtime.CompilerServices.Unsafe.As<byte, {traitLevel.EffectiveNamespace}.{traitLevel.LayoutStructName}>(");
                builder.AppendLine($"    ref global::System.Runtime.CompilerServices.Unsafe.AddByteOffset(");
                builder.AppendLine($"        ref global::System.Runtime.CompilerServices.Unsafe.As<{impl.TypeName}, byte>(");
                builder.AppendLine($"            ref global::System.Runtime.CompilerServices.Unsafe.AsRef(in self)),");
                builder.AppendLine($"        (nint){impl.BaseOffset}));");
            }

            builder.CloseBrace();
            builder.AppendLine();
        }

        /// <summary>
        /// Collects all ancestor traits (breadth-first, deduplicated) from the trait hierarchy.
        /// For IQuadrupler : IDoubler : IValueProvider, returns [IDoubler, IValueProvider].
        /// </summary>
        private static List<TraitModel> CollectAncestorTraits(TraitModel trait)
        {
            var ancestors = new List<TraitModel>();
            var visited = new HashSet<string>();
            var queue = new Queue<TraitModel>();

            foreach (var baseTrait in trait.BaseTraits)
                queue.Enqueue(baseTrait);

            while (queue.Count > 0)
            {
                var current = queue.Dequeue();
                if (!visited.Add(current.FullName))
                    continue; // Diamond dedup

                ancestors.Add(current);

                foreach (var baseTrait in current.BaseTraits)
                    queue.Enqueue(baseTrait);
            }

            return ancestors;
        }

        /// <summary>
        /// Checks whether the implementing type already provides its own {Method}_Impl override.
        /// Scans the type's members for a static method matching the expected implementation signature.
        /// </summary>
        private static bool HasUserOverride(ImplementationModel impl, TraitMethod method)
        {
            if (impl.TypeSymbol == null) return false;

            var implMethodName = method.ImplMethodName;
            foreach (var member in impl.TypeSymbol.GetMembers())
            {
                if (member is Microsoft.CodeAnalysis.IMethodSymbol ms &&
                    ms.IsStatic &&
                    ms.Name == implMethodName)
                {
                    return true;
                }
            }

            return false;
        }

        public static string GenerateExternal(ExternalImplModel external)
        {
            var trait = external.Trait!;
            var builder = new CodeBuilder();

            builder.AppendLine("// <auto-generated/>");
            builder.AppendLine("#nullable enable");
            builder.AppendLine("using System.Runtime.CompilerServices;");
            builder.AppendLine();
            builder.AppendLine($"namespace {trait.EffectiveNamespace}");
            builder.OpenBrace();

            // Extension methods class for external types
            builder.AppendLine($"public static class {trait.Name}ExternalImpls");
            builder.OpenBrace();

            // AsLayout extension for external type
            builder.AppendLine("[MethodImpl(MethodImplOptions.AggressiveInlining)]");
            builder.AppendLine($"public static ref readonly {trait.LayoutStructName} As{trait.ShortName}(");
            builder.AppendLine($"    this ref {external.TargetFullTypeName} self)");
            builder.OpenBrace();

            if (external.BaseOffset == 0)
            {
                builder.AppendLine($"return ref global::System.Runtime.CompilerServices.Unsafe.As<{external.TargetFullTypeName}, {trait.LayoutStructName}>(");
                builder.AppendLine($"    ref global::System.Runtime.CompilerServices.Unsafe.AsRef(in self));");
            }
            else
            {
                builder.AppendLine($"return ref global::System.Runtime.CompilerServices.Unsafe.As<byte, {trait.LayoutStructName}>(");
                builder.AppendLine($"    ref global::System.Runtime.CompilerServices.Unsafe.AddByteOffset(");
                builder.AppendLine($"        ref global::System.Runtime.CompilerServices.Unsafe.As<{external.TargetFullTypeName}, byte>(");
                builder.AppendLine($"            ref global::System.Runtime.CompilerServices.Unsafe.AsRef(in self)),");
                builder.AppendLine($"        (nint){external.BaseOffset}));");
            }

            builder.CloseBrace();

            builder.CloseBrace();
            builder.CloseBrace();

            return builder.ToString();
        }
    }
}
