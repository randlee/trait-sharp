using TraitSharp.SourceGenerator.Models;
using TraitSharp.SourceGenerator.Utilities;

namespace TraitSharp.SourceGenerator.Generators
{
    internal static class ExtensionMethodsGenerator
    {
        public static string Generate(TraitModel trait)
        {
            var builder = new CodeBuilder();
            var contractName = ConstraintInterfaceGenerator.GetContractName(trait);

            builder.AppendLine("// <auto-generated/>");
            builder.AppendLine("#nullable enable");
            builder.AppendLine("using System.Runtime.CompilerServices;");
            builder.AppendLine();
            builder.AppendLine($"namespace {trait.EffectiveNamespace}");
            builder.OpenBrace();

            builder.AppendLine("/// <summary>");
            builder.AppendLine($"/// Extension methods for {trait.Name} trait.");
            builder.AppendLine("/// </summary>");
            builder.AppendLine($"public static class {trait.ShortName}TraitExtensions");
            builder.OpenBrace();

            // AsLayout method - e.g., AsCoordinate
            // Uses 'this ref T self' to allow zero-copy ref return from caller's storage.
            // C# does not allow 'this in T' on generic extension methods (CS8338),
            // but 'this ref T' is allowed for struct types (C# 7.2+).
            builder.AppendLine("/// <summary>");
            builder.AppendLine("/// Zero-copy cast to layout struct for direct field access.");
            builder.AppendLine("/// </summary>");
            builder.AppendLine("[MethodImpl(MethodImplOptions.AggressiveInlining)]");
            builder.AppendLine($"public static ref readonly {trait.LayoutStructName} As{trait.ShortName}<T>(this ref T self)");
            builder.AppendLine($"    where T : unmanaged, {contractName}<T>");
            builder.OpenBrace();
            builder.AppendLine("return ref T.AsLayout(in self);");
            builder.CloseBrace();
            builder.AppendLine();

            // Individual property accessors — own only (inherited come from base trait's extensions)
            // For derived traits, OwnProperties may be empty (trait adds no new properties) — that's correct.
            var ownProps = trait.HasBaseTraits ? trait.OwnProperties : trait.Properties;
            foreach (var prop in ownProps)
            {
                builder.AppendLine("/// <summary>");
                builder.AppendLine($"/// Get {prop.Name} value.");
                builder.AppendLine("/// </summary>");
                builder.AppendLine("[MethodImpl(MethodImplOptions.AggressiveInlining)]");
                builder.AppendLine($"public static {prop.TypeName} Get{prop.Name}<T>(this ref T self)");
                builder.AppendLine($"    where T : unmanaged, {contractName}<T>");
                builder.OpenBrace();
                builder.AppendLine($"return T.Get{prop.Name}_Impl(in self);");
                builder.CloseBrace();
                builder.AppendLine();
            }

            // Method trait extension methods — own only (inherited come from base trait's extensions)
            var ownMethods = trait.HasBaseTraits ? trait.OwnMethods : trait.Methods;
            foreach (var method in ownMethods)
            {
                var returnType = method.ReturnsSelf ? "T" : method.ReturnType;

                // Build parameter list for the extension method signature
                var sigParams = "this ref T self";
                foreach (var param in method.Parameters)
                {
                    var typeName = param.IsSelf ? "T" : param.TypeName;
                    var modifier = string.IsNullOrEmpty(param.Modifier) ? "" : param.Modifier + " ";
                    sigParams += $", {modifier}{typeName} {param.Name}";
                }

                // Build argument list for forwarding to T.{Impl}(in self, ...)
                var fwdArgs = "in self";
                foreach (var param in method.Parameters)
                {
                    var modifier = string.IsNullOrEmpty(param.Modifier) ? "" : param.Modifier + " ";
                    fwdArgs += $", {modifier}{param.Name}";
                }

                builder.AppendLine("/// <summary>");
                builder.AppendLine($"/// Invoke {method.Name} on the trait.");
                builder.AppendLine("/// </summary>");
                builder.AppendLine("[MethodImpl(MethodImplOptions.AggressiveInlining)]");
                builder.AppendLine($"public static {returnType} {method.Name}{method.OverloadSuffix}<T>({sigParams})");
                builder.AppendLine($"    where T : unmanaged, {contractName}<T>");
                builder.OpenBrace();
                if (method.ReturnsVoid)
                    builder.AppendLine($"T.{method.ImplMethodName}({fwdArgs});");
                else
                    builder.AppendLine($"return T.{method.ImplMethodName}({fwdArgs});");
                builder.CloseBrace();
                builder.AppendLine();
            }

            builder.CloseBrace();
            builder.CloseBrace();

            return builder.ToString();
        }
    }
}
