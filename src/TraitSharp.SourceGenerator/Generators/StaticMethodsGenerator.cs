using TraitSharp.SourceGenerator.Models;
using TraitSharp.SourceGenerator.Utilities;

namespace TraitSharp.SourceGenerator.Generators
{
    internal static class StaticMethodsGenerator
    {
        public static string Generate(TraitModel trait)
        {
            var builder = new CodeBuilder();
            var contractName = ConstraintInterfaceGenerator.GetContractName(trait);

            builder.AppendLine("// <auto-generated/>");
            builder.AppendLine("#nullable enable");
            builder.AppendLine("using System.Runtime.CompilerServices;");
            builder.AppendLine();
            builder.AppendLine($"namespace {trait.EffectiveNamespace}");
            builder.OpenBrace();

            builder.AppendLine($"public partial interface {trait.Name}");
            builder.OpenBrace();

            // Static property accessors — own only (inherited come from base trait's static methods)
            // For derived traits, OwnProperties may be empty (trait adds no new properties) — that's correct.
            var ownProps = trait.HasBaseTraits ? trait.OwnProperties : trait.Properties;
            foreach (var prop in ownProps)
            {
                builder.AppendLine("/// <summary>");
                builder.AppendLine($"/// Static accessor for {prop.Name} across all implementers.");
                builder.AppendLine("/// </summary>");
                builder.AppendLine("[MethodImpl(MethodImplOptions.AggressiveInlining)]");
                builder.AppendLine($"static {prop.TypeName} Get{prop.Name}<T>(in T self)");
                builder.AppendLine($"    where T : unmanaged, {contractName}<T>");
                builder.OpenBrace();
                builder.AppendLine($"return T.Get{prop.Name}_Impl(in self);");
                builder.CloseBrace();
                builder.AppendLine();
            }

            // Static method dispatchers — own only (inherited come from base trait's static methods)
            var ownMethods = trait.HasBaseTraits ? trait.OwnMethods : trait.Methods;
            foreach (var method in ownMethods)
            {
                var returnType = method.ReturnsSelf ? "T" : method.ReturnType;

                var sigParams = "in T self";
                foreach (var param in method.Parameters)
                {
                    var typeName = param.IsSelf ? "T" : param.TypeName;
                    var modifier = string.IsNullOrEmpty(param.Modifier) ? "" : param.Modifier + " ";
                    sigParams += $", {modifier}{typeName} {param.Name}";
                }

                var fwdArgs = "in self";
                foreach (var param in method.Parameters)
                {
                    var modifier = string.IsNullOrEmpty(param.Modifier) ? "" : param.Modifier + " ";
                    fwdArgs += $", {modifier}{param.Name}";
                }

                builder.AppendLine("/// <summary>");
                builder.AppendLine($"/// Static dispatch for {method.Name} across all implementers.");
                builder.AppendLine("/// </summary>");
                builder.AppendLine("[MethodImpl(MethodImplOptions.AggressiveInlining)]");
                builder.AppendLine($"static {returnType} {method.Name}{method.OverloadSuffix}<T>({sigParams})");
                builder.AppendLine($"    where T : unmanaged, {contractName}<T>");
                builder.OpenBrace();
                if (method.ReturnsVoid)
                    builder.AppendLine($"T.{method.ImplMethodName}({fwdArgs});");
                else
                    builder.AppendLine($"return T.{method.ImplMethodName}({fwdArgs});");
                builder.CloseBrace();
                builder.AppendLine();
            }

            // Static AsLayout method — use 'new' for derived traits to shadow base trait's version
            // (each trait level has a different layout struct return type)
            var newPrefix = trait.HasBaseTraits ? "new " : "";
            builder.AppendLine("/// <summary>");
            builder.AppendLine("/// Zero-copy cast to layout struct.");
            builder.AppendLine("/// </summary>");
            builder.AppendLine("[MethodImpl(MethodImplOptions.AggressiveInlining)]");
            builder.AppendLine($"{newPrefix}static ref readonly {trait.LayoutStructName} AsLayout<T>(in T self)");
            builder.AppendLine($"    where T : unmanaged, {contractName}<T>");
            builder.OpenBrace();
            builder.AppendLine("return ref T.AsLayout(in self);");
            builder.CloseBrace();

            builder.CloseBrace();
            builder.CloseBrace();

            return builder.ToString();
        }
    }
}
