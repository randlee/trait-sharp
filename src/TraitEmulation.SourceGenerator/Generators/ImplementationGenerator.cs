using System.Linq;
using TraitEmulation.SourceGenerator.Models;
using TraitEmulation.SourceGenerator.Utilities;

namespace TraitEmulation.SourceGenerator.Generators
{
    internal static class ImplementationGenerator
    {
        public static string Generate(ImplementationModel impl)
        {
            var trait = impl.Trait!;
            var builder = new CodeBuilder();
            var contractName = ConstraintInterfaceGenerator.GetContractName(trait);
            var fullContractName = $"{trait.EffectiveNamespace}.{contractName}";

            builder.AppendLine("// <auto-generated/>");
            builder.AppendLine("#nullable enable");
            builder.AppendLine("using System.Runtime.CompilerServices;");
            builder.AppendLine();
            builder.AppendLine($"namespace {impl.Namespace}");
            builder.OpenBrace();

            // Implement the per-trait contract interface instead of ITrait<TraitName, TSelf>
            builder.AppendLine($"partial {impl.TypeKind} {impl.TypeName} : {fullContractName}<{impl.TypeName}>");
            builder.OpenBrace();

            // Property accessors - these have unique names per trait (GetX_Impl, GetR_Impl, etc.)
            // so they don't need explicit interface implementation
            foreach (var prop in trait.Properties)
            {
                builder.AppendLine("[MethodImpl(MethodImplOptions.AggressiveInlining)]");
                builder.AppendLine($"public static {prop.TypeName} Get{prop.Name}_Impl(in {impl.TypeName} self)");
                builder.OpenBrace();

                string fieldName;
                if (impl.FieldMapping.TryGetValue(prop.Name, out var mappedName))
                {
                    fieldName = mappedName;
                }
                else
                {
                    fieldName = prop.Name;
                }

                builder.AppendLine($"return self.{fieldName};");
                builder.CloseBrace();
                builder.AppendLine();
            }

            // TraitOffset property - use explicit interface implementation to avoid
            // name collision when a struct implements multiple traits
            builder.AppendLine($"static int {fullContractName}<{impl.TypeName}>.TraitOffset => {impl.BaseOffset};");
            builder.AppendLine();

            // Layout cast — use explicit interface implementation to avoid name collision
            // when a struct implements multiple traits (each returns a different layout type)
            builder.AppendLine("[MethodImpl(MethodImplOptions.AggressiveInlining)]");
            builder.AppendLine($"static ref readonly {trait.EffectiveNamespace}.{trait.LayoutStructName} {fullContractName}<{impl.TypeName}>.AsLayout(in {impl.TypeName} self)");
            builder.OpenBrace();

            if (impl.BaseOffset == 0)
            {
                // Trait fields start at beginning of struct — simple cast
                var fieldsList = string.Join("; ", trait.Properties.Select(p => $"{p.TypeName} {p.Name}"));
                builder.AppendLine($"// SAFETY: Generator verified {impl.TypeName} starts with {{{fieldsList}}}");
                builder.AppendLine($"return ref global::System.Runtime.CompilerServices.Unsafe.As<{impl.TypeName}, {trait.EffectiveNamespace}.{trait.LayoutStructName}>(");
                builder.AppendLine($"    ref global::System.Runtime.CompilerServices.Unsafe.AsRef(in self));");
            }
            else
            {
                // Trait fields at non-zero offset — add byte offset before cast
                builder.AppendLine($"// SAFETY: Generator verified {trait.Name} fields at byte offset {impl.BaseOffset}");
                builder.AppendLine($"return ref global::System.Runtime.CompilerServices.Unsafe.As<byte, {trait.EffectiveNamespace}.{trait.LayoutStructName}>(");
                builder.AppendLine($"    ref global::System.Runtime.CompilerServices.Unsafe.AddByteOffset(");
                builder.AppendLine($"        ref global::System.Runtime.CompilerServices.Unsafe.As<{impl.TypeName}, byte>(");
                builder.AppendLine($"            ref global::System.Runtime.CompilerServices.Unsafe.AsRef(in self)),");
                builder.AppendLine($"        (nint){impl.BaseOffset}));");
            }

            builder.CloseBrace();

            builder.CloseBrace();
            builder.CloseBrace();

            return builder.ToString();
        }

        public static string GenerateExternal(ExternalImplModel external)
        {
            var trait = external.Trait!;
            var builder = new CodeBuilder();

            builder.AppendLine("// <auto-generated/>");
            builder.AppendLine("#nullable enable");
            builder.AppendLine("using System.Runtime.CompilerServices;");
            builder.AppendLine();
            builder.AppendLine($"namespace {trait.EffectiveNamespace}");
            builder.OpenBrace();

            // Extension methods class for external types
            builder.AppendLine($"public static class {trait.Name}ExternalImpls");
            builder.OpenBrace();

            // AsLayout extension for external type
            builder.AppendLine("[MethodImpl(MethodImplOptions.AggressiveInlining)]");
            builder.AppendLine($"public static ref readonly {trait.LayoutStructName} As{trait.ShortName}(");
            builder.AppendLine($"    this ref {external.TargetFullTypeName} self)");
            builder.OpenBrace();

            if (external.BaseOffset == 0)
            {
                builder.AppendLine($"return ref global::System.Runtime.CompilerServices.Unsafe.As<{external.TargetFullTypeName}, {trait.LayoutStructName}>(");
                builder.AppendLine($"    ref global::System.Runtime.CompilerServices.Unsafe.AsRef(in self));");
            }
            else
            {
                builder.AppendLine($"return ref global::System.Runtime.CompilerServices.Unsafe.As<byte, {trait.LayoutStructName}>(");
                builder.AppendLine($"    ref global::System.Runtime.CompilerServices.Unsafe.AddByteOffset(");
                builder.AppendLine($"        ref global::System.Runtime.CompilerServices.Unsafe.As<{external.TargetFullTypeName}, byte>(");
                builder.AppendLine($"            ref global::System.Runtime.CompilerServices.Unsafe.AsRef(in self)),");
                builder.AppendLine($"        (nint){external.BaseOffset}));");
            }

            builder.CloseBrace();

            builder.CloseBrace();
            builder.CloseBrace();

            return builder.ToString();
        }
    }
}
