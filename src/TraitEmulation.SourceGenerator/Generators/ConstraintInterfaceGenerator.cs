using TraitEmulation.SourceGenerator.Models;
using TraitEmulation.SourceGenerator.Utilities;

namespace TraitEmulation.SourceGenerator.Generators
{
    internal static class ConstraintInterfaceGenerator
    {
        /// <summary>
        /// Generates the single marker interface ITrait&lt;TTrait, TSelf&gt; in the given namespace.
        /// This is generated once per namespace, not once per trait.
        /// </summary>
        public static string GenerateMarker(string ns)
        {
            var builder = new CodeBuilder();

            builder.AppendLine("// <auto-generated/>");
            builder.AppendLine("#nullable enable");
            builder.AppendLine();
            builder.AppendLine($"namespace {ns}");
            builder.OpenBrace();

            builder.AppendLine("/// <summary>");
            builder.AppendLine("/// Marker interface for trait implementations.");
            builder.AppendLine("/// Each trait defines a specific contract interface that extends this marker.");
            builder.AppendLine("/// </summary>");
            builder.AppendLine("public interface ITrait<TTrait, TSelf> where TSelf : unmanaged { }");

            builder.CloseBrace();

            return builder.ToString();
        }

        /// <summary>
        /// Generates a per-trait contract interface, e.g. ICoordinateTrait&lt;TSelf&gt;.
        /// This interface extends ITrait&lt;ICoordinate, TSelf&gt; and contains the
        /// static abstract members specific to this trait.
        /// </summary>
        public static string GenerateContract(TraitModel trait)
        {
            var builder = new CodeBuilder();
            var contractName = GetContractName(trait);

            builder.AppendLine("// <auto-generated/>");
            builder.AppendLine("#nullable enable");
            builder.AppendLine();
            builder.AppendLine($"namespace {trait.EffectiveNamespace}");
            builder.OpenBrace();

            builder.AppendLine("/// <summary>");
            builder.AppendLine($"/// Contract interface for {trait.Name} trait implementations.");
            builder.AppendLine("/// </summary>");
            builder.AppendLine($"public interface {contractName}<TSelf> : ITrait<{trait.Name}, TSelf> where TSelf : unmanaged");
            builder.OpenBrace();

            // Property accessors
            foreach (var prop in trait.Properties)
            {
                builder.AppendLine($"static abstract {prop.TypeName} Get{prop.Name}_Impl(in TSelf self);");
            }

            // AsLayout method
            builder.AppendLine($"static abstract ref readonly {trait.LayoutStructName} AsLayout(in TSelf self);");

            // TraitOffset property for TraitSpan support
            builder.AppendLine("static abstract int TraitOffset { get; }");

            builder.CloseBrace();
            builder.CloseBrace();

            return builder.ToString();
        }

        /// <summary>
        /// Gets the per-trait contract interface name: ICoordinate -> ICoordinateTrait
        /// </summary>
        public static string GetContractName(TraitModel trait)
        {
            return $"{trait.Name}Trait";
        }

        /// <summary>
        /// Gets the fully qualified per-trait contract interface name.
        /// </summary>
        public static string GetFullContractName(TraitModel trait)
        {
            return $"{trait.EffectiveNamespace}.{GetContractName(trait)}";
        }
    }
}
